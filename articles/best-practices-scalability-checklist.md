<properties
   pageTitle="Lista de comprobación de escalabilidad | Microsoft Azure"
   description="Guía de lista de comprobación de escalabilidad para problemas de diseño para el ajuste automático de Azure."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>Lista de comprobación de escalabilidad

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Diseño de servicio
- **Partición de la carga de trabajo**. Diseño de los elementos del proceso pueden descomponer e independiente. Reducir el tamaño de cada elemento, mientras sigue las reglas habituales para separación de preocupaciones y el principio de responsabilidad única. Esto permite que los componentes se distribuyan de forma que aumente el uso de cada unidad de cálculo (por ejemplo, un servidor de base de datos o función). También facilita la escala de la aplicación agregando instancias de recursos específicos. Para obtener más información, consulte [Guía de partición calcular](https://msdn.microsoft.com/library/dn589773.aspx).
- **Diseño de escala**. Escala permite aplicaciones ante carga variable aumentando y reducir el número de instancias de roles, colas y otros servicios que utilizan. Sin embargo, la aplicación debe diseñarse con esto en cuenta. Por ejemplo, la aplicación y los servicios que utiliza deben ser sin estado para permitir las solicitudes de enrutamiento a cualquier instancia. Esto también evita la adición o eliminación de instancias específicas negativo que afectan a los usuarios actuales. También debe implementar configuración o la detección automática de instancias que agrega y quita, para que pueda realizar código en la aplicación de la ruta es necesario. Por ejemplo, una aplicación web puede utilizar un conjunto de colas con un enfoque turnos enrutar solicitudes a servicios de fondo que se ejecutan en las funciones de trabajo. La aplicación web debe poder detectar cambios en el número de colas para redirigir solicitudes correctamente y equilibrar la carga de la aplicación.
- **Escala como una unidad**. Plan de recursos adicionales acomodar el crecimiento. Para cada recurso, saber la superior los límites de ajuste de escala y use sharding o descomposición para ir más allá de estos límites. Determinar las unidades de escala para el sistema de bien definidos conjuntos de recursos. Por ello aplicar operaciones de escalado más fácil y menos susceptible a impacto negativo en la aplicación a través de los límites impuestos por falta de recursos en alguna parte del sistema global. Por ejemplo, agregando x número de roles de web y trabajador podría requerir y número de colas adicionales y el número de z de cuentas de almacenamiento para controlar la carga de trabajo adicional generada por las funciones. Por lo que podría consistir en una unidad de escala x funciones web y trabajo, _y_ colas y cuentas de almacenamiento de _z_ . Diseñar la aplicación para que se ajusta fácilmente agregando una o más unidades de escala.
- **Evite afinidad del cliente**. Cuando sea posible, asegúrese de que la aplicación no requiere afinidad. Así se pueden enrutar solicitudes a cualquier instancia y el número de instancias no es relevante. Esto también evita la sobrecarga de almacenar, recuperar y mantener información de estado para cada usuario.
- **Aprovechar las características de ajuste automático de la plataforma**. Donde la plataforma de hospedaje es compatible con una capacidad de ajuste automático, como Autoescala de Azure, prefiere mecanismos personalizados o de terceros a menos que el mecanismo integrado no puede satisfacer sus necesidades. Usar reglas de escalado programadas donde posibles para asegurar que los recursos están disponibles sin un retraso de inicio, pero agregar ajuste automático reactiva a las reglas donde corresponda afrontar los cambios inesperados en petición. Puede utilizar las operaciones de ajuste automático en la API de administración de servicio para ajustar el ajuste automático y agregar contadores personalizados a las reglas. Para obtener más información, vea [Guía de escala automático](best-practices-auto-scaling.md).
- **Descargue las tareas de CPU/IO intensivo como tareas en segundo plano**. Si se espera una solicitud de un servicio a llevar mucho tiempo para ejecutar o absorber importantes recursos, descargar el procesamiento de esta solicitud a una tarea diferente. Usar funciones de trabajo o trabajos en segundo plano (dependiendo de la plataforma de hospedaje) para ejecutar estas tareas. Esta estrategia habilita el servicio continuar recibiendo más solicitudes y seguir respondiendo.  Para obtener más información, vea [Guía de trabajos de fondo](best-practices-background-jobs.md).
- **Distribuir la carga de trabajo para tareas en segundo plano**. Donde hay muchas de las tareas de fondo o las tareas que requieren mucho tiempo o recursos, distribuir el trabajo en varias unidades de cálculo (por ejemplo, los roles de trabajo o trabajos en segundo plano). Para obtener una posible solución, consulte la [Trama de los consumidores competir](https://msdn.microsoft.com/library/dn568101.aspx).
- **Considere la posibilidad de mover hacia un _compartir nada_ arquitectura**. Una arquitectura de no compartir nada usa nodos independientes, autosuficientes con ningún punto de conflicto (por ejemplo, servicios compartidos o almacenamiento). En teoría, este sistema puede escalar casi indefinidamente. Mientras un enfoque totalmente sin elementos compartidos no suele ser práctico para la mayoría de las aplicaciones, puede proporcionar las oportunidades de diseño para una mejor escalabilidad. Por ejemplo, evitar el uso del estado de la sesión de servidor, afinidad del cliente y partición de datos son buenos ejemplos de mover hacia una arquitectura de no compartir nada.

## <a name="data-management"></a>Administración de datos

- **Partición de datos de uso**. Dividir los datos en varias bases de datos y servidores de base de datos o diseño de la aplicación para utilizar el almacenamiento de datos de servicios que puede proporcionar esta división transparente (base de datos de elásticos de base de datos de SQL de Azure y ejemplos almacenamiento de tablas de Azure). Este enfoque puede ayudar a maximizar el rendimiento y permitir que sea más fácil de ajuste de escala. Existen diferentes particiones técnicas, como horizontal, vertical y funcionales. Puede usar una combinación de las siguientes opciones para obtener el máximo beneficio de rendimiento de la consulta mayor, escalabilidad más sencillo, administración más flexible, mejor disponibilidad y para que coincida con el tipo de almacén de los datos que contendrá. Además, considere la posibilidad de utilizar distintos tipos de almacén de datos para diferentes tipos de datos, elija los tipos en función de cómo están optimizados para el tipo de datos específico. Esto puede incluir el uso de almacenamiento de tablas, la base de datos de un documento o un almacén de datos de la familia de columna, en lugar de o así como una base de datos relacional. Para obtener más información, vea [Guía de partición de datos](best-practices-data-partitioning.md).
- **Diseño de la coherencia**. La coherencia mejora la escalabilidad de reducción o quitando el tiempo necesario para sincronizar los datos relacionados dividir entre varios stores. El coste es que datos no sean siempre coherentes cuando se lee y algunos escribir operaciones pueden causar conflictos. La coherencia es ideal para situaciones donde se lea con frecuencia pero escritos con poca frecuencia los mismos datos. Para obtener más información, consulte el [Manual de la coherencia de datos](https://msdn.microsoft.com/library/dn589800.aspx).
- **Reducir interacciones conversadoras entre componentes y servicios**. Evite el diseño en el que se requiere una aplicación para realizar varias llamadas a un servicio de interacciones (cada una de las cuales devuelve una cantidad pequeña de datos), en lugar de una sola llamada que puede devolver todos los datos. Cuando sea posible, combine varias operaciones relacionadas en una sola solicitud cuando la llamada a un servicio o componente que tiene una latencia perceptible. Esto facilita la supervisión de rendimiento y optimizar operaciones complejas. Por ejemplo, use procedimientos almacenados en bases de datos para encapsulados lógica compleja y reducir el número de ida y vuelta y el bloqueo de recursos.
- **Usar colas para redistribuir la carga de escritura de datos de alta velocidad**. Picos en la demanda de un servicio pueden saturar ese servicio y provocar errores crecientes. Para evitar esto, considere la posibilidad de implementar el [modelo de redistribución de carga basado en cola](https://msdn.microsoft.com/library/dn589783.aspx). Use una cola que actúa como un búfer entre una tarea y un servicio que se invoca. Esto puede suave cargas intermitente que de lo contrario pueden provocar errores en el servicio o la tarea hasta que desaparezca.
- **Minimizar la carga en el almacén de datos**. El almacén de datos suele ser una botella de procesamiento, un recurso de costo y a menudo no es fácil de escalar. Cuando sea posible, quite lógica (como el procesamiento de documentos XML u objetos JSON) del almacén de datos y realizar el procesamiento dentro de la aplicación. Por ejemplo, en lugar de pasar XML a la base de datos (distinto de una cadena opaca para el almacenamiento), serializar o deserializar XML en el nivel de aplicación y pasar de forma nativa el almacén de datos. Es normalmente mucho más fácil escalar la aplicación que el almacén de datos, por lo que debe intentar realizar todo el procesamiento de descarga intensiva como sea posible dentro de la aplicación.
- **Recupera minimizar el volumen de datos**. Recuperar solo los datos que necesita especificando las columnas y el uso de criterios para seleccionar filas. Asegúrese de uso de los parámetros de valor de tabla y el nivel de aislamiento adecuado. Mecanismos de usar como etiquetas de entidad para evitar la recuperación de datos innecesariamente.
- **Usar agresiva almacenamiento en caché**. Utilice la caché siempre que sea posible reducir la carga de recursos y servicios que generan o proporcionar datos. Almacenamiento en caché normalmente se adapta a los datos que son relativamente estático o que requiera mucho procesamiento para obtener. Almacenamiento en caché debe realizarse en todos los niveles donde corresponda en cada nivel de la aplicación, incluida la generación de interfaz de usuario y de acceso de datos. Para obtener más información, consulte las [Instrucciones de almacenamiento en caché](best-practices-caching.md).
- **Controlar el crecimiento de datos y retención**. La cantidad de datos almacenados en una aplicación aumenta con el tiempo. Este crecimiento aumenta los costos de almacenamiento y aumenta la latencia al acceder a los datos, lo que afecta a la aplicación y rendimiento. Es posible periódicamente archivar algunos de los datos antiguos que ya no se accede, o mover los datos que casi nunca se tiene acceso a almacenamiento a largo plazo que es más rentable, incluso si la latencia de acceso es superior.
- **Optimizar transferir objetos de datos (dto) con un formato binario eficaz**. Muchas veces dto pasan entre las capas de una aplicación. Reducir el tamaño, reduce la carga de recursos y la red. Sin embargo, saldo los ahorros con la sobrecarga de conversión de los datos en el formato necesario en cada ubicación donde se utiliza. Adoptar un formato que tenga la máxima interoperabilidad para habilitar fácil reutilización de un componente.
- **Establecer el control de la memoria caché**. Diseñar y configurar la aplicación para utilizar la caché de resultados o de fragmentos en caché cuando sea posible, para reducir la carga de procesamiento.
- **Habilitar la caché del cliente**. Aplicaciones Web deben habilitar la configuración de la caché en el contenido que pueden almacenarse en caché. Esto suele estar desactivada de forma predeterminada. Configurar el servidor para ofrecer la caché correspondiente encabezados de control para habilitar la caché del contenido de los clientes y servidores proxy.
- **Almacenamiento de blobs de Azure de uso y la red de entrega de contenido de Azure para reducir la carga de la aplicación**. Considere almacenar contenido público estático o relativamente estático, como imágenes, recursos, scripts y hojas de estilo, en el almacenamiento de blobs. Este enfoque evita la aplicación de la carga causada por generar dinámicamente este contenido para cada solicitud. Además, considere la posibilidad de usar la red de entrega de contenido para este contenido en caché y ofrecer a los clientes. Uso de la red de entrega de contenido puede mejorar el rendimiento en el cliente, porque el contenido se envía desde el centro de datos geográfica más cercana que contiene una caché de red de entrega de contenido. Para obtener más información, consulte la [Guía de red de entrega de contenido](best-practices-cdn.md).
- **Optimizar y ajustar las consultas SQL y los índices**. Algunas instrucciones SQL T o construcciones pueden tener un impacto en el rendimiento se puede reducir al optimizar el código en un procedimiento almacenado. Por ejemplo, evite la conversión de tipos de **fecha y hora** a un **varchar** antes de comparar con un valor literal de **fecha y hora** . Utilice las funciones de comparación de fecha y hora. Falta de índices adecuados también puede ralentizar la ejecución de la consulta. Si utiliza un marco de asignación relacional de objetos, comprender cómo funciona y cómo puede afectar a la capa de acceso a datos de rendimiento. Para obtener más información, vea la [Optimización de consultas](https://technet.microsoft.com/library/ms176005.aspx).
- **Considere la posibilidad de anular Normalizar datos**. Normalización de datos ayuda a evitar incoherencias y la duplicación. Sin embargo, mantener varios índices, comprobación de la integridad referencial, realizar varios accesos a pequeños bloques de datos y combinar tablas para volver a ensamblar los datos constituye una sobrecarga que puede afectar al rendimiento. Tenga en cuenta si algunos volumen de almacenamiento adicional y duplicación es aceptable para reducir la carga en el almacén de datos. Además, tenga en cuenta si la propia aplicación (que es normalmente más fácil de escalar) se puede utilizar para tomar el control de tareas como la administración de la integridad referencial para reducir la carga en el almacén de datos. Para obtener más información, vea [Guía de partición de datos](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## <a name="service-implementation"></a>Implementación del servicio
- **Utilizar llamadas asincrónicas**. Siempre que sea posible, use código asincrónico al acceso a recursos o servicios que pueden estar limitados por i/OS o ancho de banda de red o que tienen una latencia perceptible, con el fin de evitar el bloqueo el subproceso de llamada. Para implementar operaciones asincrónicas, utilice la [Trama asincrónica basada en tareas (pulse)](https://msdn.microsoft.com/library/hh873175.aspx).
- **Evitar el bloqueo de recursos y usar un método optimista en su lugar**. Nunca bloquear el acceso a recursos como almacenamiento u otros servicios que tienen una latencia perceptible, porque esta es una causa principal de un mal rendimiento. Usar siempre optimistas métodos para administrar operaciones simultáneas, como la escritura en el almacenamiento. Usar características de la capa de almacenamiento para administrar los conflictos. En aplicaciones distribuidas, pueden datos solo finalmente coherentes.
- **Comprimir datos pueden comprimibles mucho sobre una latencia alta, redes de bajo ancho de banda**. En la mayoría de los casos en una aplicación web, el mayor volumen de datos generados por la aplicación y pasan a través de la red es respuestas HTTP a las solicitudes de cliente. Compresión de HTTP puede reducir esto considerablemente, especialmente para contenido estático. Esto puede reducir costos, además de reducir la carga en la red, aunque comprime contenido dinámico aplicar una forma fraccionada; mayor carga en el servidor. En otros más generalizados entornos, puede reducir el volumen de datos transmitidos y minimizar el tiempo de transferencia y costos de compresión de datos, pero los procesos de compresión y descompresión sobrecarga. Por lo tanto, sólo se debe utilizar compresión cuando hay una ganancia demostrar en el rendimiento. Otros métodos de serialización, como JSON o codificaciones binarias, pueden reducir el tamaño de carga teniendo menos impacto en el rendimiento, mientras que XML es probable que aumenta.
- **Minimizar el tiempo que se usan las conexiones y los recursos**. Mantener las conexiones y recursos solo para siempre y cuando necesite usarlas. Por ejemplo, abra Conexiones de lo más tarde posible y permitir que se devuelven a la agrupación de conexiones tan pronto como sea posible. Adquirir recursos lo más tarde posible y deshacerse de ellos tan pronto como sea posible.
- **Minimizar el número de conexiones necesarios**. Conexiones de servicio absorben recursos. Limitar el número que se requieren y asegurarse de que las conexiones existentes se reutilizan siempre que sea posible. Por ejemplo, después de realizar la autenticación, utilice suplantación donde corresponda para que se ejecute código como una identidad específica. Esto puede ayudar a hacer mejor uso de la agrupación de conexiones mediante la reutilización de conexiones.

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **Enviar solicitudes en lotes para optimizar el uso de la red**. Por ejemplo, enviar y leer mensajes en lotes al acceder a una cola y realizar varias lee o escribe como un lote al acceder a almacenamiento o la caché. Esto puede ayudar a maximizar la eficacia de la almacena datos y servicios reduciendo el número de llamadas a través de la red.
- **Evite necesario para almacenar el estado de la sesión de servidor** siempre que sea posible. Administración de estado de sesión de servidor normalmente requiere la afinidad del cliente (que es, enrutamiento cada solicitud a la misma instancia del servidor), lo que afecta a la capacidad del sistema para escalar. Lo ideal es que, debe diseñar clientes independiente con respecto a los servidores que utilicen. Sin embargo, si la aplicación debe mantener el estado de sesión, almacenar datos confidenciales o grandes volúmenes de datos de cada cliente en una caché distribuida de servidor que pueden tener acceso todas las instancias de la aplicación.
- **Optimizar esquemas de almacenamiento de tabla**. Cuando se usa la tabla almacena que requieren los nombres de tabla y columna se pasa y procesar con todas las consultas, como el almacenamiento de tablas de Azure, considere la posibilidad de utilizar nombres más cortos para reducir esta sobrecarga. Sin embargo, no sacrifique la legibilidad o la capacidad de administración con nombres demasiado compacto.
- **Usar la biblioteca (TPL) para realizar operaciones de asincrónicas**. TPL facilita la escritura de código asincrónico que ejecuta las operaciones de entrada y salida. Use _ConfigureAwait_ siempre que sea posible eliminar la dependencia de continuación en un contexto de sincronización específica. Esto reduce las posibilidades de que se produzca el bloqueo de subproceso.
- **Crear dependencias de recursos durante la implementación o en el inicio de la aplicación**. Evite llamadas repetidas a métodos que probar la existencia de un recurso y, a continuación, cree el recurso si no existe. (Métodos como _CloudTable.CreateIfNotExists_ y _CloudQueue.CreateIfNotExists_ en la biblioteca de cliente de almacenamiento de Azure siguen este patrón). Estos métodos pueden imponer una carga considerable si invoca a antes de cada acceso a una tabla de almacenamiento o cola de almacenamiento. En su lugar:
 - Crear los recursos necesarios cuando se implementa la aplicación, o cuando inicie por primera vez (una sola llamada a _CreateIfNotExists_ para cada recurso en el código de inicio de una función web o de trabajo es aceptable). Sin embargo, asegúrese de controlar las excepciones que pueden surgir si su código intenta obtener acceso a un recurso que no existe. En estos casos, debe registrar la excepción y posiblemente alertas a un operador que falta un recurso.
 - En algunos casos, puede ser apropiado crear el recurso que falta como parte de la excepción de código de control. Pero debe adoptar este enfoque con cuidado como la no existencia del recurso podría ser indicativa de un error de programación (un nombre de recurso mal escrita por ejemplo), o algún otro problema de nivel de infraestructura.
- **Marcos ligeros de uso**. Elija con cuidado las API y marcos que usar para minimizar el uso de recursos, el tiempo de ejecución y carga total en la aplicación. Por ejemplo, mediante Web API para controlar las solicitudes de servicio puede reducir el tamaño de la aplicación y aumentar la velocidad de ejecución, pero puede que no sea adecuado para los escenarios avanzados donde se requiere las capacidades adicionales de Windows Communication Foundation.
- **Considere la posibilidad de reducir el número de cuentas de servicio**. Por ejemplo, utilice una cuenta específica para tener acceso a recursos o servicios que imponen un límite de conexiones o realizan mejor donde se mantienen menos conexiones. Este enfoque es comunes para los servicios, como bases de datos, pero puede afectar a la capacidad de auditoría con precisión operaciones debido a la suplantación de usuario original.
- **Llevar los perfiles de rendimiento y pruebas de carga** durante el desarrollo, como parte de rutinas de prueba y antes de la versión final para asegurarse de que realiza la aplicación y escalas según sea necesario. Este pruebas deben realizarse en el mismo tipo de hardware como la plataforma de producción y con los mismos tipos y cantidades de datos y de usuario se carga como que encontrará en producción. Para obtener más información, vea [probar el rendimiento de un servicio de nube](vs-azure-tools-performance-profiling-cloud-services.md).
