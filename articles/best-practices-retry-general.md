<properties
   pageTitle="Vuelva a intentar directrices generales | Microsoft Azure"
   description="Guía de intentos de control de errores transitorias."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="retry-general-guidance"></a>Vuelva a intentar directrices generales

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="overview"></a>Información general

Todas las aplicaciones que se comuniquen con recursos y servicios remotos deben tener en cuenta a errores transitorias. Esto ocurre especialmente para las aplicaciones que se ejecutan en la nube, donde la naturaleza de la conectividad a través de Internet y el entorno significa que están probable que se encuentra más a menudo estos tipos de errores. Errores transitorias incluyen la pérdida de conectividad de red y servicios de componentes instantáneo, la disponibilidad de un servicio o tiempos de espera que se producen cuando un servicio está ocupado. Estos errores suelen corrección automática y si se repite la acción después de un retraso adecuado es probable que se realice correctamente.

Este documento trata las directrices generales para el control de errores transitorias. Para obtener información sobre el tratamiento de errores transitorias al usar los servicios de Microsoft Azure, vea [directrices de reintentos de Azure específicos del servicio](best-practices-retry-service-specific.md).

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>¿Por qué se producen errores transitorias en la nube?

Errores transitorias pueden ocurrir en cualquier entorno, cualquier plataforma o sistema operativo y cualquier tipo de aplicación. En las soluciones que ejecutar en local, infraestructura local, el rendimiento y la disponibilidad de la aplicación y sus componentes es normalmente mantiene a través de la redundancia de hardware caro y utilizados con frecuencia en y componentes y los recursos están ubicados cerca de cada otro. Esto es menos probable que un error, aún puede dar lugar en errores transitorias - e incluso una interrupción a través de imprevistos como fuente de alimentación externa o problemas de red u otros escenarios de desastres.

Nube de hospedaje, incluidos los sistemas de nube privada, puede ofrecer una mayor disponibilidad general mediante recursos compartidos, redundancia, migración tras error automática y asignación de recursos dinámicos a través de un gran número de nodos de cálculo de mercancías. Sin embargo, la naturaleza de estos entornos puede significa que son más probable que se produzcan errores transitorias. Existen varios motivos para ello:

* Muchos de los recursos en un entorno de nube están compartidos y acceso a estos recursos está sujeto a limitación para proteger el recurso. Algunos servicios no conexiones cuando aumenta la carga a un nivel específico o se alcanza una tasa de rendimiento máximo, para permitir el procesamiento de las solicitudes existentes y mantener el rendimiento del servicio para todos los usuarios. Limitación ayuda a mantener la calidad de servicio para vecinos y otros inquilinos utilizando el recurso compartido.
* Entornos de nube se generan con gran cantidad de unidades de hardware de mercancías. Rendimiento al distribuir dinámicamente la carga entre varias unidades informáticos y componentes de la infraestructura, y a ofrecer confiabilidad automáticamente reciclaje o reemplazando las unidades de error. Esta naturaleza dinámica significa que pueden producirse en ocasiones transitorias y errores de conexión temporal.
* A menudo, hay varios componentes de hardware, incluida la infraestructura de red, como enrutadores y equilibradores de carga, entre la aplicación y los recursos y servicios que utiliza. La infraestructura adicional en ocasiones puede introducir errores de conexión transitorias y latencia de conexión adicionales.
* Condiciones de red entre el cliente y el servidor pueden ser variable, especialmente cuando comunicación cruza Internet. Incluso en ubicaciones locales, cargas de gran tráfico podrán lentas comunicaciones y provocar errores intermitentes de conexión.

## <a name="challenges"></a>Desafíos
Errores transitorias pueden tener un gran impacto en la disponibilidad aparente de una aplicación, incluso si se ha probado completamente en todas las circunstancias pronosticadas. Para asegurarse de que aplicaciones hospedadas en nube funcionan de manera fiable, debe poder responder a los siguientes desafíos:

* La aplicación pueda detectar errores cuando se producen y determinar si es probable que ser transitorias, más larga duración estos errores o terminal errores. Recursos diferentes están probable que devolver respuestas diferentes cuando se produce un error y estas respuestas también pueden variar según el contexto de la operación; Por ejemplo, la respuesta para un error al leer de almacenamiento pueden diferir de respuesta para un error al escribir en el almacenamiento. Muchos de los recursos y servicios tienen contratos de comprobados error temporal. Sin embargo, donde dicha información no está disponible, puede ser difícil de encontrar la naturaleza de los errores y es probable que sea transitorias.
* La aplicación debe volver a intentar la operación si determina que el error es probable que se transitorias y realizar un seguimiento de la cantidad de veces que se ha intentado la operación.
* La aplicación debe utilizar una estrategia adecuada para los reintentos. Esta estrategia especifica el número de veces debe reintentar, el tiempo de retraso entre cada intento y las acciones para hacer después de un error al intentar. El número de intentos y el tiempo de retraso entre cada uno adecuado suelen ser difícil determinar y varían según el tipo de recurso, así como las condiciones de funcionamiento actuales del recurso y la propia aplicación.

## <a name="general-guidelines"></a>Instrucciones generales
Las siguientes instrucciones le ayudará a diseñar un error transitorio adecuado entregando mecanismo para las aplicaciones:

* **Determinar si hay un mecanismo de reintento integrado:**
  * Muchos servicios proporcionan una biblioteca SDK o cliente que contiene un error transitorio mecanismo de control. La directiva de reintento utiliza normalmente se adapta a la naturaleza y los requisitos del servicio de destino. Como alternativa, resto interfaces para servicios pueden devolver información que es útil para determinar si un reintento es apropiada y, a continuación, ¿cuánto tiempo debe esperar antes de la siguiente reintento.
  * Utilice el mecanismo de reintento integrado donde está disponible a menos que tenga requisitos específicos y bien conocidos que significan que un comportamiento diferente intentos es más apropiado.
* **Determinar si es adecuada para volver a intentar la operación**:
  * Solo debe reintentar operaciones donde los errores son transitorios (normalmente indicado por la naturaleza del error) y, si hay al menos algunas probabilidad de que la operación se realice correctamente cuando reattempted. No hay ningún punto en volviendo a intentar operaciones que indican una operación no válida, como una base de datos actualizar a un elemento que no existe, o solicitudes a un servicio o recurso que se ha producido un error grave
  * En general, debe implementar reintentos sólo donde se puede determinar el impacto de esta completo y las condiciones comprenden perfectamente y se puedan validar. Si no es así, dejar que el código de llamada para implementar reintentos. Recuerde que los errores devuelven de recursos y servicios fuera de su control pueden evolucionar con el tiempo y puede que necesite revisar la lógica de detección de errores transitorias.
  * Al crear servicios o componentes, considere la posibilidad de implementación de códigos de error y mensajes que le ayudarán a los clientes a determinar si debe volver a intentar operaciones de error. Indicar en particular, si el cliente debe volver a intentar la operación (quizás si devuelve un valor de **isTransient** ) y sugerir un retraso antes de que la siguiente reintento adecuado. Si crea un servicio web, considere la posibilidad de devolver errores personalizados definidos dentro de los contratos de servicio. Aunque genéricos clientes pueden no ser capaces de leer estos, le será de utilidad al generar a clientes personalizados.
* **Determinar un número de reintentos adecuado y el intervalo:**
  * Es fundamental para optimizar el número de reintentos y el intervalo en el tipo de caso de uso. Si no reintentar un número suficiente de veces, la aplicación no podrá completar la operación y es probable que experimente un error. Si Reintentar demasiadas veces o con demasiado corta un intervalo entre intentos, la aplicación puede contener potencialmente recursos como memoria, conexiones y subprocesos para períodos de tiempo, negativo afectará el estado de la aplicación.
  * Los valores apropiados para el intervalo de tiempo y el número de reintentos dependen del tipo de operación que se intentó realizar. Por ejemplo, si la operación es parte de una interacción del usuario, el intervalo debe ser corta y solo unos reintentos para evitar que los usuarios se espere una respuesta (que contiene conexiones abiertas y pueden reducir la disponibilidad de otros usuarios). Si la operación es parte de un flujo de trabajo de larga ejecución o crítica, donde la cancelación y reiniciar el proceso es costosas o lentas, es conveniente esperar más tiempo entre intentos y vuelva a intentarlo más veces.
  * Determinar los intervalos entre reintentos adecuados es la parte más difícil de diseñar una estrategia satisfactoria. Estrategias típicas usan los siguientes tipos de intervalo entre intentos:
      * **Interrupción exponencial**. La aplicación espera poco tiempo antes del primer reintento y, a continuación, en aumento exponencial horas entre cada intentos subsiguientes. Por ejemplo, puede volver a intentar la operación de 3 segundos, 12, 30 segundos y así sucesivamente.
      * **Intervalos incrementales**. La aplicación espera poco tiempo antes del primer reintento y aumenta las horas entre cada intentos subsiguientes de forma incremental. Por ejemplo, puede volver a intentar la operación de 3 segundos, 7, 13 segundos y así sucesivamente.
      * **Intervalos regulares**. La aplicación espera para el mismo período de tiempo entre cada intento. Por ejemplo, puede reintentar la operación cada 3 segundos.
      * **Vuelva a intentar de inmediato**. A veces un error transitorio es muy breve, tal vez causados por un evento como un conflicto de paquetes de red o un pico en un componente de hardware. En este caso, es apropiado volver a intentar la operación inmediatamente, porque puede tener éxito si se resolvió el problema en el tiempo que requiere la aplicación a ensamblar y envíe la solicitud siguiente. Sin embargo, nunca debería ser más de un intento de reintentos y debe cambiar estrategias alternativas, como como exponencial interrupción o acciones de reserva, si se produce un error en el reintento inmediato.
      * **Aleatorio**. Cualquiera de los intentos estrategias enumeradas anteriormente puede incluir un aleatorio para evitar varias instancias del cliente enviar reintentos subsiguientes al mismo tiempo. Por ejemplo, una instancia puede reintentar la operación después de 3 segundos, 11 segundos, 28 segundos y así sucesivamente mientras otra instancia puede reintentar la operación después de 4 segundos, 12 segundos, 26, y así sucesivamente. Aleatorio es una técnica útil que se puede combinar con otras estrategias.  
  * Como regla general, use una estrategia de interrupción exponencial para operaciones en segundo plano y estrategias de intentos de intervalo inmediato o normal para operaciones interactivas. En ambos casos, debe elegir el retraso y el número de reintentos para que la latencia máxima para todos los reintentos está dentro de los requisitos de latencia de llevar a cabo necesarios.
  * Tenga en cuenta la combinación de todos los factores que contribuyen a que el tiempo de espera máximo global para una operación a intentar. Estos factores incluyen el tiempo necesario para que un error en la conexión generar una respuesta (normalmente establece un valor de tiempo de espera en el cliente), así como el tiempo de retraso entre reintentos y el número máximo de reintentos. El total de todas las veces que estos puede provocar gran operación general veces, especialmente cuando usa una estrategia de retraso exponencial donde el intervalo entre intentos crece rápidamente después de cada error. Si un proceso debe cumplir un determinado nivel acuerdo de servicio (SLA), el tiempo de operación global, incluidos todos los tiempos de espera y retrasos, debe dentro de ella definirse en el SLA
  * Estrategias de reintento demasiado minuciosa, que tienen intervalos demasiado cortos o demasiado podrán reintentos, pueden tener efectos negativos en el recurso de destino o el servicio. Esto puede impedir que el recurso o servicio de recuperación de su estado de sobrecarga y seguirá bloquear o rechazar solicitudes. Esta en una tendencia dónde se envían las solicitudes de cada vez más para el recurso o servicio y, en consecuencia, su capacidad para recuperar los resultados se reduce aún más.
  * Tenga en cuenta el tiempo de espera de las operaciones al elegir los intervalos de reintento para evitar iniciar intentos posteriores inmediatamente (por ejemplo, si el tiempo de espera es similar al intervalo de reintento). También tenga en cuenta si debe mantener el posible período total (el tiempo de espera más los intervalos de reintento) a debajo de un tiempo total específico. Pueden influir en las operaciones que tienen los tiempos de espera muy largo o corto demasiado cuánto tarda en espera y a continuación, la frecuencia con que vuelva a intentar la operación.
  * Usar el tipo de excepción y los datos que contiene, o los mensajes y códigos de error devuelven por el servicio, para optimizar el intervalo y el número de reintentos. Para códigos de error, algunas excepciones o ejemplo (como HTTP código 503 Servicio no disponible con un encabezado después de reintento en la respuesta) pueden indicar podría duración el error, o que el servicio ha fallado y no se responde a los intentos subsiguientes.
* **Evite patrones**:
  * En la mayoría de los casos, debe evitar implementaciones que incluyen capas duplicados de código de reintento. Evite los diseños que incluyen mecanismos de reintento en cascada o que implementar intentos en cada fase de una operación que implica a una jerarquía de solicitudes, a menos que tienen requisitos específicos que requieren esto. Estos excepcional, use directivas que evitar que los números excesivo de reintentos y períodos de retraso y a continuación, asegúrese de que comprendan las consecuencias. Por ejemplo, si un componente realiza una solicitud a otra, qué accesos, a continuación, el servicio de destino e implementa intentos con un recuento de tres en ambas llamadas habrá nueve Reintentar intentos en total en el servicio. Muchos de los servicios y recursos de implementan un mecanismo de reintento integrado y debe investigar cómo puede deshabilitar o modificar esto si necesita implementar reintentos de un nivel superior.
  *  Nunca implementar un mecanismo de reintento infinito. Esto es probable que evitar el recurso o servicio de recuperación de situaciones de sobrecarga y provocar limitación y conexiones para continuar durante un período más rechazadas. Use un número limitado o reintentos o implementar un patrón como [disyuntor](http://msdn.microsoft.com/library/dn589784.aspx) para permitir que el servicio recuperar.
  * No realizar más de una vez un reintentos.
  * Evitar el uso de un intervalo de reintento normal, especialmente si tiene un gran número de reintentos, cuando tenga acceso a los servicios y recursos en Azure. El enfoque óptimo es que este escenario es una estrategia de interrupción exponencial con una capacidad de circuito más reciente.
  * Evitar que varias instancias del mismo cliente o varias instancias de clientes, envíe reintentos al mismo tiempo. Si es probable que se produzcan, introducir aleatorio en los intervalos de reintento.
* **Pruebe su estrategia de reintento e implementación:**
  * Asegúrese de que probar completamente su implementación de la estrategia de reintento en como el ancho de un conjunto de circunstancias como sea posible, especialmente cuando tanto la aplicación y los recursos de destino o servicios utiliza están bajo extremas de carga. Para comprobar el comportamiento durante las pruebas, puede:
      * Insertar transitorias y no transitorios errores en el servicio. Por ejemplo, enviar solicitudes no válidas o agregar código que detecta solicita y responde con diferentes tipos de errores de prueba. Para obtener un ejemplo usando TestApi, vea [Pruebas de inserción de errores con TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) y [Introducción a TestApi-parte 5: API de inyección de errores de código administradas](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).
      * Crear un boceto del recurso o servicio que devuelve un intervalo de errores que puede devolver el servicio real. Asegúrese de que abarcan todos los tipos de error que su estrategia de reintento está diseñada para detectar.
      * Forzar errores transitorios deshabilitando temporalmente o sobrecarga el servicio si es un servicio personalizado que ha creado e implementado (, por supuesto, no los recursos compartidos de sobrecarga o servicios de Azure compartidos).
      * API basadas en HTTP, considere la posibilidad de usar la biblioteca de FiddlerCore en las pruebas automatizadas para cambiar el resultado de las solicitudes HTTP, mediante la adición de horas extra de ida y vuelta o cambiando la respuesta (por ejemplo, el código de estado HTTP, encabezados, cuerpo y otros factores). Esto permite probar determinista de un subconjunto de las condiciones de error si transitorias errores u otros tipos de error. Para obtener más información, consulte [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore). Para obtener ejemplos de cómo usar la biblioteca, especialmente la clase **HttpMangler** , examine el [código fuente para el SDK de almacenamiento de Azure](https://github.com/Azure/azure-storage-net/tree/master/Test).
      * Realizar pruebas simultáneas para asegurarse de que el mecanismo de reintento y estrategia funciona correctamente en las siguientes circunstancias y no tiene un efecto negativo sobre el funcionamiento del cliente o provocar la contaminación entre las convocatorias y factor de carga es alta.
* **Administrar las configuraciones de directivas de reintento:**
  * Un _reintento directiva_ es una combinación de todos los elementos de la estrategia de reintento. Define el mecanismo de detección que determina si un error está resultarle transitorias, el tipo de intervalo usar (por ejemplo, normal, exponencial interrupción y aleatorio), los valores de intervalo real y el número de veces para volver a intentarlo.
  * Deben implementar reintentos en varios lugares dentro de par la aplicación más sencilla y en cada nivel de las aplicaciones más complejas. En lugar de codificar los elementos de cada directiva en varias ubicaciones, considere la posibilidad de usar un punto central para almacenar todas las directivas. Por ejemplo, almacenar los valores, como el intervalo de reintento recuento en archivos de configuración de aplicación, leerlos en tiempo de ejecución y crear mediante programación las directivas de reintento. Esto facilita para administrar la configuración y modificar y ajustar los valores para responder a cambiar requisitos y escenarios. Sin embargo, diseñar el sistema para almacenar los valores en lugar de volver a leer una configuración de archivo cada vez y asegúrese de que se usan los valores predeterminados adecuados si no se puede obtener los valores de configuración.
  * En una aplicación de servicios de nube de Azure, considere la posibilidad de almacenar los valores que se usan para crear las directivas de reintento en tiempo de ejecución en el archivo de configuración de servicio para que se pueden cambiar sin necesidad de reiniciar la aplicación.
  * Aproveche predeterminado o integrado estrategias de reintento disponibles en el cliente de API que utiliza, pero sólo donde son adecuadas para su situación. Estas estrategias son normalmente generales. En algunos casos pueden ser todo lo que es necesario, pero en otros escenarios no pueden ofrecen la completa gama de opciones que se adapten a sus necesidades específicas. Debe comprender cómo la configuración afectará a la aplicación a través de pruebas para determinar los valores más adecuados.
* **Inicie sesión y realizar un seguimiento de los errores transitorias y no transitorios:**
  * Como parte de la estrategia de reintento, incluir excepciones y otras herramientas que inicie sesión cuando se realizan reintentos. Aunque un error temporal ocasional y vuelva a intentarlo son normal y no indican un problemas, regulares crecientes números y de reintentos son a menudo un indicador de un problema que puede producir un error o actualmente afectar al rendimiento de la aplicación y la disponibilidad.
  * Inicie transitorias errores como entradas de advertencia en lugar de entradas de Error para que los sistemas de control no detectarlos como errores de aplicación que se pueden activar alertas falsas.
  * Considere almacenar un valor en las entradas de registro que indica si los reintentos producidos por limitación en el servicio o por otros tipos de errores como errores de conexión, para que pueda diferenciarlos durante el análisis de los datos. Un aumento en el número de errores de limitación a menudo es un indicador de un error de diseño en la aplicación o la necesidad de cambiar a un servicio de premium que ofrece hardware dedicado.  
  * Considere la posibilidad de medición y registrar el tiempo total de las operaciones que incluyen un mecanismo de reintento. Esto es un buen indicador del efecto general de transitorias errores en los tiempos de respuesta del usuario, latencia de proceso y la eficacia de los casos de uso de la aplicación. También se produjo el número de reintentos de registro para comprender los factores que han aumentado el tiempo de respuesta.
  * Considere la posibilidad de implementar una telemetría y supervisar el sistema que puede generar alertas cuando el número y la tasa de errores, el promedio de reintentos o aumenta las horas generales tomadas para que operaciones correctamente.
* **Administrar operaciones que continuamente un error:**
  * Habrá circunstancias donde la operación continúa errores en cada intento y es fundamental para tener en cuenta cómo tratar esta situación:
      * Aunque una estrategia de reintento definirá el número máximo de veces que se debe volver a intentar una operación, no evita que la aplicación repetir la operación de nuevo, con el mismo número de reintentos. Por ejemplo, si se produce un error en un servicio de procesamiento de pedido con un error grave que pone fuera de la acción de forma permanente, la estrategia de reintento puede detectar un tiempo de espera de la conexión y tenga en cuenta que sea un error transitorio. El código se vuelva a intentar la operación de un número determinado de veces y asígnele hacia arriba. Sin embargo, cuando otro cliente realiza un pedido, la operación se intenta nuevamente - aunque es que no se ejecute cada vez.
      * Para evitar que reintentos continuas de las operaciones que se producirá un error continuamente, considere la posibilidad de implementar el [disyuntor de trama](http://msdn.microsoft.com/library/dn589784.aspx). En este modelo, si el número de fracasos dentro de una ventana de tiempo especificado supera el umbral, las solicitudes se devuelven a la persona que llama inmediatamente como errores, sin intentar obtener acceso al recurso que ha fallado o servicio.
      * La aplicación periódicamente puede probar el servicio, de forma intermitente y con muchas intervalos entre solicitudes para detectar cuando esté disponible. Un intervalo adecuado dependerá del escenario, como la importancia de la operación y la naturaleza del servicio y puede ser cualquier cosa entre unos minutos y varias horas. En el punto donde la prueba se realiza correctamente, la aplicación puede reanudar las operaciones normales y pasar las solicitudes del servicio recién recuperado.
      * Mientras tanto, es posible volver a otra instancia del servicio (quizás en un centro de datos diferente o aplicación), utiliza un servicio similar que ofrece una funcionalidad compatible (tal vez más simple) o realizar algunas operaciones alternativos con la esperanza de que el servicio estará disponible próximamente. Por ejemplo, puede ser conveniente almacenar solicitudes para el servicio de una cola o reproducen más adelante y almacén de datos. En caso contrario, es posible que pueda redirigir al usuario a una instancia de la aplicación alternativa, degradar el rendimiento de la aplicación, pero seguir ofreciendo funcionalidad aceptable o simplemente devuelto presentar de un mensaje para el usuario que indica que no está disponible en la aplicación.

* **Otras consideraciones**
  * Decidir los valores para el número de reintentos y los intervalos de una directiva de reintento, tenga en cuenta si la operación en el servicio o recurso es parte de una operación de ejecución larga o varios pasos. Puede ser difícil o caro compensa la los demás operaciones pasos que ya han realizado correctamente cuando uno falla. En este caso, un intervalo muy largo y un gran número de reintentos pueden ser aceptables siempre y cuando no bloquear otras operaciones manteniendo o bloquear recursos escasos.
  * Tenga en cuenta si al volver a intentar la misma operación puede causar incoherencias en los datos. Si se repiten algunas partes de un proceso de varios pasos y las operaciones no son idempotentes, puede traducirse en una incoherencia. Por ejemplo, una operación que incrementa un valor si se repite, devolverá un resultado no válido. Una operación que envía un mensaje a una cola de repetición puede causar una incoherencia en consumidor del mensaje si no puede detectar mensajes duplicados. Para evitar esto, asegúrese de diseñar cada paso como una operación idempotente. Para obtener más información acerca de idempotencia, vea [Modelos de idempotencia](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).
  * Tenga en cuenta el ámbito de las operaciones que se volverá a. Por ejemplo, puede ser más fácil de implementar código de reintento en un nivel que abarca varias operaciones y vuelva a intentar todos ellos si se produce un error. Sin embargo, hacerlo puede provocar problemas idempotencia u operaciones de deshacer innecesarios.
  * Si elige un ámbito de reintento que abarca varias operaciones, tenga en cuenta la latencia total de todos ellos determinar los intervalos de reintento, cuando el tiempo necesario de supervisión y antes de generar las alertas de errores.
  * Considere la posibilidad de cómo la estrategia de reintento puede afectar vecinos y otros inquilinos en una aplicación compartida o cuando se usa servicios y recursos compartidos. Directivas de reintento agresiva pueden provocar un número mayor de errores transitorias para estos otros usuarios y para las aplicaciones que comparten los recursos y servicios. Del mismo modo, la aplicación puede verse afectada por las directivas de reintento implementadas con otros usuarios de los servicios y recursos. Para las aplicaciones críticas, decide usar servicios premium que no se comparten. Esto le ofrece un mayor control sobre la carga y la consiguiente limitación de estos recursos y servicios, que pueden ayudar a justificar el costo adicional.

## <a name="more-information"></a>Más información

* [Directrices de Azure Reintentar de específicos del servicio](best-practices-retry-service-specific.md)
* [El bloque de aplicaciones de control de errores transitorias](http://msdn.microsoft.com/library/hh680934.aspx)
* [Disyuntor patrón](http://msdn.microsoft.com/library/dn589784.aspx)
* [Trama de transacción de compensación](http://msdn.microsoft.com/library/dn589804.aspx)
* [Patrones de idempotencia](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)
